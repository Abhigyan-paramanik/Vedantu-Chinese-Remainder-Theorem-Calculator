function toBigIntStrict(v){try{return v===""||v===undefined?null:BigInt(v)}catch(e){return null}}function mod(a,m){const r=a%m;return r>=0n?r:r+m}function abs(a){return a<0n?-a:a}function gcd(a,b){a=abs(a),b=abs(b);while(b)[a,b]=[b,a%b];return a}function egcd(a,b){let[old_r,r]=[a,b],[old_s,s]=[1n,0n],[old_t,t]=[0n,1n];while(r!==0n){const q=old_r/r;[old_r,r]=[r,old_r-q*r],[old_s,s]=[s,old_s-q*s],[old_t,t]=[t,old_t-q*t]}return old_r<0n&&(old_r=-old_r,old_s=-old_s,old_t=-old_t),[old_r,old_s,old_t]}function invMod(a,m){const[g,x]=egcd(a,m);return g!==1n?null:mod(x,m)}const modeEl=document.getElementById("mode"),countEl=document.getElementById("count"),rowsEl=document.getElementById("rows"),outEl=document.getElementById("output"),stepsBox=document.getElementById("stepsBox"),optLatex=document.getElementById("optLatex");function clampCountToMin1(){let n=Number(countEl.value||0);return n=!Number.isFinite(n)||n<0?0:n}function renderInputs(){const n=clampCountToMin1(),mode=modeEl.value;rowsEl.innerHTML="";for(let i=0;i<n;i++){const row=document.createElement("div");row.className="row",row.innerHTML="congruence"===mode?`<div class="rowhead">constraint ${i+1}: x ≡ a<sub>${i+1}</sub> (mod n<sub>${i+1}</sub>)</div><div class="rowgrid"><div class="col-6"><label>a<sub>${i+1}</sub></label><input data-k="a" placeholder="residue a"></div><div class="col-6"><label>n<sub>${i+1}</sub></label><input data-k="n" placeholder="modulus n"></div></div>`:`<div class="rowhead">Constraint ${i+1}: c·x ≡ d (mod n)</div><div class="rowgrid"><div class="col-4"><label>c</label><input data-k="c" placeholder="coefficient c"></div><div class="col-4"><label>d</label><input data-k="d" placeholder="rhs d"></div><div class="col-4"><label>n</label><input data-k="n" placeholder="modulus n (positive)"></div></div>`,rowsEl.appendChild(row)}outEl.textContent="",stepsBox.innerHTML='<div class="note">Enter constraints, then hit Solve.</div>'}function addStepBlock(title,summary,explanation){stepsBox.querySelector(".note")&&(stepsBox.innerHTML="");const block=document.createElement("div");block.className="stepBlock";const t=document.createElement("div");t.className="stepTitle",t.textContent=title;const details=document.createElement("details"),summ=document.createElement("summary");summ.textContent=summary;const body=document.createElement("div");body.className="muted",body.style.marginTop="10px",optLatex.checked?body.innerHTML=explanation.map(s=>`<div>${s}</div>`).join(""):(body.style.whiteSpace="pre-wrap",body.style.fontFamily="ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace",body.textContent=explanation.join("\n")),details.appendChild(summ),details.appendChild(body),block.appendChild(t),block.appendChild(details),stepsBox.appendChild(block)}function addStaticBlock(title,lines){stepsBox.querySelector(".note")&&(stepsBox.innerHTML="");const block=document.createElement("div");block.className="stepBlock";const t=document.createElement("div");t.className="stepTitle",t.textContent=title,block.appendChild(t);lines&&lines.length>0&&((body=document.createElement("div")).className="muted",optLatex.checked?body.innerHTML=lines.map(l=>`<div>${l}</div>`).join(""):body.textContent=lines.join("\n"),block.appendChild(body));stepsBox.appendChild(block)}async function typesetSteps(){optLatex.checked&&window.MathJax?.typesetPromise&&(await window.MathJax.typesetPromise([stepsBox]).catch(()=>{}))}async function solve(){outEl.textContent="Calculating...",stepsBox.innerHTML="";const nRows=clampCountToMin1();if(0===nRows)return outEl.textContent="Please enter at least one constraint.",stepsBox.innerHTML='<div class="note">No constraints to solve.</div>',void 0;const mode=modeEl.value,rows=Array.from(rowsEl.querySelectorAll(".row"));try{const rawInputs=[];for(let i=0;i<rows.length;i++){const row=rows[i],get=k=>row.querySelector(`[data-k="${k}"]`)?.value||"";if("congruence"===mode){const a_raw=get("a"),n_raw=get("n");if(""===a_raw||""===n_raw)throw new Error(`Constraint ${i+1}: Please fill in both a and n.`);const a=toBigIntStrict(a_raw),n=toBigIntStrict(n_raw);if(null===a||null===n)throw new Error(`Constraint ${i+1}: Please enter valid integers.`);if(0n===n)throw new Error(`Constraint ${i+1}: Modulus must be a nonzero integer.`);rawInputs.push({a:a,n:n})}else{const c_raw=get("c"),d_raw=get("d"),n_raw=get("n");if(""===c_raw||""===d_raw||""===n_raw)throw new Error(`Constraint ${i+1}: Please fill in c, d, and n.`);const c=toBigIntStrict(c_raw),d=toBigIntStrict(d_raw),n=toBigIntStrict(n_raw);if(null===c||null===d||null===n)throw new Error(`Constraint ${i+1}: Please enter valid integers.`);if(0n===n)throw new Error(`Constraint ${i+1}: Modulus must be a nonzero integer.`);rawInputs.push({c:c,d:d,n:n})}}const inputLines=[];for(let i=0;i<rawInputs.length;i++){const item=rawInputs[i];"congruence"===mode?inputLines.push(`x \\equiv ${item.a} \\pmod{${item.n}}`):inputLines.push(`${item.c} \\cdot x \\equiv ${item.d} \\pmod{${item.n}}`)}addStaticBlock("Restated problem",inputLines.map(l=>`\\(${l}\\)`));const normalized=[],step1Exp=["For each congruence:"];for(let i=0;i<rawInputs.length;i++){const item=rawInputs[i],ni=abs(item.n);"congruence"===mode?(normalized.push({a:mod(item.a,ni),n:ni,type:"std"}),step1Exp.push(`Constraint ${i+1}: \\(x \\equiv ${item.a} \\pmod{${item.n}} \\to x \\equiv ${mod(item.a,ni)} \\pmod{${ni}}\\)`)):(normalized.push({c:mod(item.c,ni),d:mod(item.d,ni),n:ni,type:"lin"}),step1Exp.push(`Constraint ${i+1}: \\(${item.c}x \\equiv ${item.d} \\pmod{${item.n}} \\to ${mod(item.c,ni)}x \\equiv ${mod(item.d,ni)} \\pmod{${ni}}\\)`))}addStepBlock("Step 1: Normalization","Normalize all congruences.",step1Exp);const standard=[],step2Exp=[];let hadLinear=normalized.some(n=>"lin"===n.type);if(hadLinear){for(let i=0;i<normalized.length;i++){const item=normalized[i];if("std"===item.type)standard.push({a:item.a,n:item.n}),step2Exp.push(`Constraint ${i+1}: Already in standard form \\(x \\equiv ${item.a} \\pmod{${item.n}}\\).`);else{const{c:c,d:d,n:n}=item,g=gcd(c,n);if(0n!==mod(d,g))throw addStaticBlock("No solution exists",[`Reason: conflict modulo gcd. In constraint ${i+1}, \\(\\gcd(${c}, ${n}) = ${g}\\) does not divide \\(${d}\\).`]),new Error("No solution");const c_prime=c/g,d_prime=d/g,n_prime=n/g,inv=invMod(c_prime,n_prime),a_final=mod(d_prime*inv,n_prime);standard.push({a:a_final,n:n_prime}),step2Exp.push(`Constraint ${i+1}: \\(${c}x \\equiv ${d} \\pmod{${n}}\\) has \\(g=${g}\\). Reduced to \\(${c_prime}x \\equiv ${d_prime} \\pmod{${n_prime}}\\). Inverse is \\(${inv}\\). Standard form: \\(x \\equiv ${a_final} \\pmod{${n_prime}}\\).`)}}addStepBlock("Step 2: Reduction of linear congruences","Reduce the linear congruence to standard form.",step2Exp)}else for(const item of normalized)standard.push({a:item.a,n:item.n});const step3Exp=[];let pairwiseCoprime=!0;if(standard.length>1){for(let i=0;i<standard.length;i++)for(let j=i+1;j<standard.length;j++){const g=gcd(standard[i].n,standard[j].n);step3Exp.push(`\\(\\gcd(${standard[i].n}, ${standard[j].n}) = ${g}\\)`),1n!==g&&(pairwiseCoprime=!1)}step3Exp.push(pairwiseCoprime?"All gcd values are 1. The moduli are pairwise coprime.":"Not all gcd values are 1. The moduli are not pairwise coprime.")}else step3Exp.push("Single congruence present.");addStepBlock("Step 3: System classification","Determine whether the system is pairwise coprime.",step3Exp);let finalA,finalN;const step4Exp=[];if(1===standard.length)finalA=standard[0].a,finalN=standard[0].n,step4Exp.push(`The single congruence \\(x \\equiv ${finalA} \\pmod{${finalN}}\\) is the solution.`),addStepBlock("Step 4: Solution method","Only one congruence is present.",step4Exp);else if(pairwiseCoprime){let N=1n;for(const s of standard)N*=s.n;step4Exp.push(`Total modulus \\(N = \\prod n_i = ${N}\\).`);let x=0n;for(let i=0;i<standard.length;i++){const{a:a,n:n}=standard[i],Ni=N/n,Mi=invMod(Ni,n);x+=a*Ni*Mi,step4Exp.push(`Constraint ${i+1}: \\(N_${i+1} = ${Ni}\\), \\(M_${i+1} = ${Mi}\\), \\(\\text{term} = ${a} \\cdot ${Ni} \\cdot ${Mi} = ${a*Ni*Mi}\\)`)}finalA=mod(x,N),finalN=N,step4Exp.push(`Constructed solution \\(x \\equiv \\sum (a_i \\cdot N_i \\cdot M_i) \\equiv ${x} \\equiv ${finalA} \\pmod{${finalN}}\\).`),addStepBlock("Step 4: Solution method","Apply the Classic Chinese Remainder Theorem.",step4Exp)}else{let curA=standard[0].a,curN=standard[0].n;for(let i=1;i<standard.length;i++){const a2=standard[i].a,n2=standard[i].n,g=gcd(curN,n2);if(0n!==mod(a2-curA,g))throw addStaticBlock("No solution exists",[`Reason: conflict modulo gcd. Residues \\(${curA}\\) and \\(${a2}\\) conflict modulo \\(\\gcd(${curN}, ${n2}) = ${g}\\).`]),new Error("No solution");const n1_prime=curN/g,n2_prime=n2/g,diff=(a2-curA)/g,inv=invMod(n1_prime,n2_prime),t=mod(diff*inv,n2_prime),nextA=curA+curN*t,nextN=curN*n2/g;step4Exp.push(`Merge ${i}: \\(x \\equiv ${curA} \\pmod{${curN}}\\) and \\(x \\equiv ${a2} \\pmod{${n2}}\\) merge to \\(x \\equiv ${nextA} \\pmod{${nextN}}\\).`),curA=nextA,curN=nextN}finalA=curA,finalN=curN,addStepBlock("Step 4: Solution method","Merge congruences sequentially.",step4Exp)}const step5Exp=[];for(let i=0;i<standard.length;i++){const{a:a,n:n}=standard[i],check=mod(finalA,n);step5Exp.push(`Constraint ${i+1}: \\(${finalA} \\bmod ${n} = ${check}\\). ${check===a?"Verified.":"FAILED."}`)}addStepBlock("Step 5: Verification (optional)","Verify the solution.",step5Exp),addStaticBlock("Final answer",[`\\[x \\equiv ${finalA} \\pmod{${finalN}}\\]`,`\\[x = ${finalA} + k \\cdot ${finalN}, k \\in \\mathbb{Z}\\]`]);let summaryText="";1===standard.length?summaryText=`Single constraint solved: x ≡ ${finalA} (mod ${finalN})`:pairwiseCoprime?summaryText=`All moduli are pairwise coprime. Solved using Classic CRT: x ≡ ${finalA} (mod ${finalN})`:summaryText=`Moduli are not pairwise coprime. Solved using Generalized CRT (Sequential Merge): x ≡ ${finalA} (mod ${finalN})`,outEl.textContent=summaryText,await typesetSteps()}catch(e){"No solution"===e.message?outEl.textContent="No solution exists due to residue conflict modulo the gcd of the moduli.":outEl.textContent="Error: "+e.message,await typesetSteps()}}document.getElementById("solveBtn").addEventListener("click",solve),modeEl.addEventListener("change",renderInputs),countEl.addEventListener("input",renderInputs),renderInputs();